var utils        = require('protean'),
    Path         = require('./path'),
    EventEmitter = require('events').EventEmitter,
    stop         = utils.alias('break'),
    ObjectTraverse;
//---------------------------------------------------------------------------
// ObjectTraverse Factory
//---------------------------------------------------------------------------
ObjectTraverse = utils.inherit(EventEmitter, {
    /**
     * @param {Object} [opts={}] An object of option settings
     *      @property {String} [opts.typeKey] Attribute key for node 'type'
     *      @property {Array|Object|Function} [opts.childKeys] Child keys of nodes
     *      @property {Function} [opts.enter] Function to call when entering a node
     *      @property {Function} [opts.leave] Function to call when leaving a node
     *      @property {Function} [opts.every] Function to call when entering or
     *          leaving a node
     * @param {Object} [obj] An object-tree to traverse
     * @returns {Object}
     */
    constructor: function ObjectTraverse (opts, obj) {
        var path = new Path(this),
            childKeys;

        opts = opts || {};

        ObjectTraverse.superclass.call(this);

        this.subject = obj;
        this.typeKey = opts.typeKey;
        this.childKeys = childKeys = opts.childKeys;
        this.childKeysIsArray = utils.isArray(childKeys);
        this.childKeysIsFn = utils.isFunction(childKeys);

        utils.each(['every', 'enter', 'leave'], function (name) {
            var val = opts[name];
            if (utils.isFunction(val)) {
                this.on(name, val);
            }
        }, this);

        this.path    = path;
        this.visited = [];
        this.visit   = [];
    },
    
    //-----------------------------------------------------------------------
    // Traversal
    //-----------------------------------------------------------------------
    /**
     * @param {Object} [obj] An object tree to traverse
     */
    walk: function (obj) {
        var path    = this.path,
            visited = this.visited,
            visit   = this.visit,
            node, i, nodes, child;

        obj = obj || this.subject;

        if (!obj) {
            throw new Error('ObjectTraverse#walk() needs something to traverse.');
        }
        
        visit.push(obj);
        
        while (visit.length) {
            node = visit.pop();
            if (node) {
                // pre-traversal
                path.push(node);
                this.emit('enter');

                if (this.BREAk) {
                    break;
                }
                else if (!this.SKIP) {
                    visit.push(null);
                    visited.push(node);

                    nodes = this.getAllChildren(node);
                    i = nodes.length;
                    while (i--) {
                        child = nodes[i];
                        visit.push(child);
                    }
                }
            }
            else {
                // post-traversal
                node = visited.pop();
                if (node) {
                    this.emit('leave');

                    if (this.BREAK) {
                        break;
                    }
                    else if (this.REVISIT) {
                        visit.push(node);
                    }
                    else {
                        path.pop();
                    }
                }
            }
        }

        path.reset();
        visit.length = visited.length = 0;

        return this;
    },

    start:    utils.alias('walk'),
    traverse: utils.alias('walk'),

    setFlag: function (name) {
        if (!utils.has(this, name)) {
            Object.defineProperty(this, name, {
                get: function () {
                    delete this[name];
                    return true;
                },
                enumerable: true,
                configurable: true
            });
        }
        return this;
    },

    "break": utils.alias('setFlag', ['BREAK']),
    stop:    utils.alias('setFlag', ['BREAK']),
    skip:    utils.alias('setFlag', ['SKIP']),
    revisit: utils.alias('setFlag', ['REVISIT']),
    //-----------------------------------------------------------------------
    // Events
    //-----------------------------------------------------------------------
    /**
     * Fired when first entering a object node
     * @event ObjectTraverse#enter
     * @type {ObjectTraverse.PathCursor} The cursor for path node access
     * @type {ObjectTraverse} The current ObjectTraverse instance
     * 
     * Fired when leaving a object node
     * @event ObjectTraverse#leave
     * @type {ObjectTraverse.PathCursor} The cursor for path node access
     * @type {ObjectTraverse} The current ObjectTraverse instance
     * 
     * Fired for every node
     * @event ObjectTraverse#*
     * @type {ObjectTraverse.PathCursor} The cursor for path node access
     * @type {ObjectTraverse} The current ObjectTraverse instance
     * 
     * If the ObjectTraverse instance is configured with a `typeKey` will fire an
     * event of `[enter|leave]:[nodeType]` when entering or leaving a node.
     * @event ObjectTraverse#[enter|leave]:[nodeType]
     * @type {ObjectTraverse.PathCursor} The cursor for node
     * @type {ObjectTraverse} The current ObjectTraverse instance
     */
    off: utils.alias('removeListener'),

    __emit__: EventEmitter.prototype.emit,
    /**
     * @fires ObjectTraverse#enter
     * @fires ObjectTraverse#leave
     * @fires ObjectTraverse#*
     * @fires ObjectTraverse#[enter|leave]:[nodeType]
     * @param {String} name Name of the event
     * @returns {ObjectTraverse} The current instance
     */
    emit: function (name) {
        var typeKey = this.typeKey,
            path = this.path,
            cursor = path.getCursor(),
            node = cursor.node,
            key;

        this.__emit__('*', cursor, this);
        this.__emit__(name, cursor, this);

        if (typeKey && (key = node[typeKey])) {
            this.__emit__(name + ':' + key, cursor, this);
        }

        return this;
    },
    //-----------------------------------------------------------------------
    // Utility
    //-----------------------------------------------------------------------
    destroy: function () {
        this.removeAllListeners();

        this.path.destroy();
        this.visit.destroy();
        this.visited.destroy();

        delete this.path;
        delete this.visit;
        delete this.visited;
        delete this.childKeys;
        delete this.typeKey;
        delete this.subject;
    },
    /**
     * Return the 'child' keys for this obj.  If child keys are defined,
     * and an array, those keys will be tried on the obj.  If provided a
     * typeKey, and childKeys is an object, if the subject has the typeKey
     * as a property, that will be used to determine which child keys are
     * used from the childKeys object.
     * 
     * @param {Object} obj
     * @returns {String[]}
     */
    getChildKeys: function (obj) {
        var typeKey   = this.typeKey,
            childKeys = this.childKeys,
            getKeys   = this.childKeysIsFn ? childKeys : utils.keys,
            keys;

        if (typeKey && childKeys && !this.childKeysIsArray) {
            keys = childKeys[obj[typeKey]] || [];
        }
        else if (childKeys && this.childKeysIsArray) {
            keys = childKeys;
        }
        else {
            keys = getKeys(obj) || [];
        }

        return keys;
    },
    /**
     * Get the named child node(s).  If not given a name, returns all child nodes.
     * @param {Object} obj
     * @param {String} [name]
     * @returns {Object[]}
     */
    getChildren: function (obj, name) {
        var children = [];

        if (!name) {
            return this.getAllChildren(obj);
        }

        if (~this.getChildKeys(obj).indexOf(name)) {
            children = obj[name];
            return (utils.isArray(children) ?
                children : [children]).
                filter(function (child) {
                    return child && typeof child === 'object';
                });
        }

        return children;
    },
    /**
     * Return all child nodes for the object
     * @param {Object} obj
     * @returns {Object[]}
     */
    getAllChildren: function (obj) {
        var self = this;
        return utils.chain(this.getChildKeys(obj)).
            map(function (key) {
                return self.getChildren(obj, key);
            }).
            filter(Boolean).
            flatten().
            value();
    }    
});
//---------------------------------------------------------------------------
// Exports
//---------------------------------------------------------------------------
ObjectTraverse.Path = Path;
module.exports = ObjectTraverse;
